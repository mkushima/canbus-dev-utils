#!/usr/bin/env python3

import argparse
import can
import isotp
import os
import udsoncan

from logger import MyLogger
from udsoncan.connections import PythonIsoTpConnection
from udsoncan.client import Client
from udsoncan.configs import default_client_config


# Logger setup
logger = MyLogger(os.path.basename(__file__))


def get_args():
    def hex_int(value):
        try:
            return int(value, 16)
        except ValueError:
            raise argparse.ArgumentTypeError(f"'{value}' is not a valid hexadecimal integer")

    parser = argparse.ArgumentParser(
        prog='uds-client',
        description='UDS Client application'
    )

    parser.add_argument(
        "-ch", "--can_channel",
        help="CAN channel interface",
        required=True,
        type=str
    )

    parser.add_argument(
        "--rx_id",
        help="ID used for reception (in HEX)",
        required=True,
        type=hex_int
    )

    parser.add_argument(
        "--tx_id",
        help="ID used for transmission (in HEX)",
        required=True,
        type=hex_int
    )

    return parser.parse_args()


def main():
    args = get_args()

    can_channel = args.can_channel
    rx_id = args.rx_id
    tx_id = args.tx_id

    # Refer to isotp documentation for full details about parameters
    isotp_params = {
        'stmin' : 100,                         # Time between consecutive frame. 0-127ms or 100-900ns with values from 0xF1-0xF9
        'blocksize' : 10,                      # Consecutives frames before sending a new flow control message
        'wftmax' : 0,                          # Number of wait frame allowed before triggering an error
        'tx_data_length' : 8,                  # Link layer (CAN layer) works with 8 byte payload (CAN 2.0)
        'tx_data_min_length' : 8,              # Minimum length of CAN messages. When different from None, messages are padded to meet this length. Works with CAN 2.0 and CAN FD.
        'tx_padding' : 0xAA,                   # Will pad all transmitted CAN messages with byte 0xAA.
        'rx_flowcontrol_timeout' : 1000,       # Triggers a timeout if a flow control is awaited for more than 1000 milliseconds
        'rx_consecutive_frame_timeout' : 1000, # Triggers a timeout if a consecutive frame is awaited for more than 1000 milliseconds
        'max_frame_size' : 4095,               # Limit the size of receive frame.
    }

    # Link Layer (CAN protocol)
    bus = can.Bus(
        channel=can_channel,
        interface='socketcan',
    )

    # Network layer addressing scheme
    tp_addr = isotp.Address(
        isotp.AddressingMode.Normal_29bits,
        txid=tx_id,
        rxid=rx_id,
    )

    # Network/Transport layer (IsoTP protocol)
    stack = isotp.CanStack(
        bus=bus,
        address=tp_addr,
        params=isotp_params,
    )
    
    # interface between Application and Transport layer
    conn = PythonIsoTpConnection(stack)

    config = dict(default_client_config)
    config['data_identifiers'] = {
        0xF190: udsoncan.AsciiCodec(17)       # Codec that read ASCII string. We must tell the length of the string
    }

    with Client(conn, request_timeout=2, config=config) as client:
        resp = client.read_data_by_identifier([0xF190])
        logger.info(resp.service_data.values)

    bus.shutdown()

if __name__ == '__main__':
    main()
